
// Synchronous task
console.log("Synchronous Log 1");

// Macro-task 
setInterval(()=>{
    console.log("Interval Log 1 after 100 ms");
}, 100);

setTimeout(()=>{
    console.log("Timeout Log 1 after 1000 ms");
}, 1000);

// Micro-task
Promise.resolve().then(()=>{
    console.log("Promise Log 1");
})

// Synchronous task
console.log("Synchronous Log 2");


// In JavaScript, the event loop manages the execution of asynchronous code using a system of queues, primarily the macrotask queue and the microtask queue. These queues dictate the order in which callbacks from asynchronous operations are processed.
// Macrotasks:
// Represent larger, independent tasks that are scheduled for future execution.
// Have lower priority compared to microtasks.
// Examples include:
// setTimeout() and setInterval() callbacks
// I/O operations (e.g., network requests, file system operations)
// User interface events (e.g., clicks, keyboard input)
// requestAnimationFrame() callbacks
// Parsing HTML and producing the DOM
// Microtasks:
// Represent smaller, more urgent tasks that update the application's state.
// Have higher priority than macrotasks and are executed immediately after the currently executing script and before the next macrotask.
// Examples include:
// Promise callbacks (.then(), .catch(), .finally())
// queueMicrotask()
// MutationObserver callbacks
// process.nextTick() in Node.js
// Execution Order:
// The JavaScript event loop works as follows:
// Execute the current script: The main thread executes synchronous JavaScript code from the call stack.
// Process the microtask queue: Once the call stack is empty, the event loop processes all pending microtasks in the microtask queue until it's empty. New microtasks added during this phase are also processed within the same iteration.
// Process one macrotask: After the microtask queue is cleared, the event loop picks one macrotask from the macrotask queue and executes it.
// Repeat: The cycle then repeats, processing any new microtasks generated by the executed macrotask, and then moving to the next macrotask in the queue.
// Key Difference:
// The fundamental difference lies in their priority and execution timing. Microtasks are prioritized and executed within the same event loop iteration, ensuring that critical state updates or reactions to promises are handled promptly. Macrotasks, being less time-sensitive, are scheduled for later iterations, allowing for browser rendering or other I/O operations to occur in between. This prioritization helps maintain a responsive user interface and efficient handling of asynchronous operations.
                                     
/* ==========================================
   |                                         |          ++++++++++++++++++++++++++++
   |                                         |          |        WEB API           |
   |                                         |          |                          |
   |                                         |          |                          |
   |                                         |          |                          |
   |                                         |          |                          |
   |                                         |          |                          |        
   |                                         |          ++++++++++++++++++++++++++++
   |                                         |  
   |                                         | 
   ===========================================
      CALL STACK
    
      MICRO-TASK QUEUE (Promises)(first priority)
      ==========================
                             
                             
       Promise.resolve().then(()=>{
         console.log("Promise Log 1");
         })                       
                              
      ==========================

        MACRO-TASK QUEUE (setTimeout, setInterval)
        ==========================
       setTimeout(()=>{
    console.log("Timeout Log 1 after 0 ms");
}, 0);
        ==========================
*/

// Final Output Order:
// Synchronous Log 1
// Synchronous Log 2
// Promise Log 1
// Timeout Log 1 after 0 ms